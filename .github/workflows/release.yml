name: Release

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      bump:
        description: "SemVer bump to apply when run manually"
        default: patch
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      services:
        description: "Services to build (comma-separated: agent,aggregator,frontend) or 'all' for all services"
        default: all
        required: false
        type: string

env:
  REGISTRY: ${{ vars.REGISTRY != '' && vars.REGISTRY || 'docker.io/dawker' }}
  HOMELAB_DEPLOYMENTS_REPO: ${{ vars.HOMELAB_DEPLOYMENTS_REPO != '' && vars.HOMELAB_DEPLOYMENTS_REPO || 'slashr/homelab-deployments' }}
  HOMELAB_DEPLOYMENTS_BRANCH: ${{ vars.HOMELAB_DEPLOYMENTS_BRANCH != '' && vars.HOMELAB_DEPLOYMENTS_BRANCH || 'main' }}
  HOMELAB_DEPLOYMENTS_SERVICES: ${{ vars.HOMELAB_DEPLOYMENTS_SERVICES != '' && vars.HOMELAB_DEPLOYMENTS_SERVICES || 'agent,aggregator,frontend' }}
  SKIP_RELEASE_LABELS: ${{ vars.SKIP_RELEASE_LABELS != '' && vars.SKIP_RELEASE_LABELS || 'skip release,no release,ci-only,infra-only,docs-only' }}

jobs:
  prepare-release:
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'push'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    outputs:
      version: ${{ steps.bump_version.outputs.version }}
      release_enabled: ${{ steps.service_gate.outputs.enabled }}
      services: ${{ steps.service_matrix.outputs.services }}
      services_csv: ${{ steps.service_matrix.outputs.services_csv }}
    steps:
      - name: Check out merged commit
        uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}
          fetch-depth: 0

      - name: Fetch tags
        run: git fetch --tags --force

      - name: Gather PR metadata
        id: pr_metadata
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const sha = context.sha;
            core.setOutput('labels', '[]');
            core.setOutput('merge_sha', sha);
            core.setOutput('number', '');
            core.setOutput('has_pr', 'false');
            
            // Try to find PR associated with this commit
            // For merge commits, we may need to check the commit message or try multiple approaches
            let pr = null;
            
            try {
              // First, try to find PRs associated with this commit SHA
              const response = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: sha,
              });
              
              if (response.data.length > 0) {
                pr = response.data[0];
              } else {
                // If no PR found, try to find recently merged PRs and match by merge commit
                // This handles cases where the API hasn't indexed the merge commit yet
                const recentPRs = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'closed',
                  sort: 'updated',
                  direction: 'desc',
                  per_page: 10,
                });
                
                // Find PR that was merged with this commit SHA
                for (const candidatePR of recentPRs.data) {
                  if (candidatePR.merge_commit_sha === sha) {
                    pr = candidatePR;
                    break;
                  }
                }
              }
              
              if (pr) {
                const labels = pr.labels.map((label) => label.name);
                core.setOutput('labels', JSON.stringify(labels));
                core.setOutput('merge_sha', pr.merge_commit_sha || sha);
                core.setOutput('number', String(pr.number));
                core.setOutput('has_pr', 'true');
                core.info(`Using labels from PR #${pr.number}: ${labels.join(', ')}`);
              } else {
                core.info(`No pull request found for commit ${sha}`);
              }
            } catch (error) {
              core.warning(`Unable to fetch PR metadata: ${error.message}`);
            }

      - name: Export release metadata
        run: |
          {
            echo "LABELS_JSON=${{ steps.pr_metadata.outputs.labels || '[]' }}"
            echo "HAS_PR=${{ steps.pr_metadata.outputs.has_pr || 'false' }}"
            echo "MERGE_SHA=${{ steps.pr_metadata.outputs.merge_sha || github.sha }}"
          } >> "$GITHUB_ENV"

      - name: Decide release gate
        id: release_gate
        env:
          EVENT_NAME: ${{ github.event_name }}
        run: |
          python - <<'PY'
          import json, os

          labels_raw = os.environ.get("LABELS_JSON", "[]")
          try:
              labels = [str(label).lower() for label in json.loads(labels_raw)]
          except json.JSONDecodeError:
              labels = []

          skip_terms = {
              term.strip().lower()
              for term in os.environ.get("SKIP_RELEASE_LABELS", "").split(",")
              if term.strip()
          }

          event = os.environ.get("EVENT_NAME", "")
          has_pr = os.environ.get("HAS_PR", "false").lower() == "true"
          skip = any(label in skip_terms for label in labels)

          enabled = "true"
          if event != "workflow_dispatch":
              if not has_pr:
                  enabled = "false"
                  print("Release skipped: no PR metadata.")
              elif skip:
                  enabled = "false"
                  print("Release skipped: PR labeled to skip release.")

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
              fh.write(f"enabled={enabled}\n")

          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as env_file:
              env_file.write(f"RELEASE_ENABLED={enabled}\n")
          PY

      - name: Determine diff base
        if: env.RELEASE_ENABLED == 'true' && github.event_name != 'workflow_dispatch'
        id: diff_base
        run: |
          set -euo pipefail
          base="${{ github.event.before }}"
          if [[ -z "$base" || "$base" == "0000000000000000000000000000000000000000" ]]; then
            # For merge commits, try to find the merge base
            if git rev-parse HEAD^2 >/dev/null 2>&1; then
              # This is a merge commit, use the first parent (main branch before merge)
              base="$(git rev-parse HEAD^1)"
            elif git rev-parse HEAD^ >/dev/null 2>&1; then
              base="$(git rev-parse HEAD^)"
            else
              base="$(git hash-object -t tree /dev/null)"
            fi
          fi
          echo "sha=$base" >> "$GITHUB_OUTPUT"

      - name: Detect changed services
        if: env.RELEASE_ENABLED == 'true' && github.event_name != 'workflow_dispatch'
        id: service_filter
        uses: dorny/paths-filter@v3
        with:
          base: ${{ steps.diff_base.outputs.sha }}
          ref: ${{ github.sha }}
          filters: |
            agent:
              - 'agent/**'
            aggregator:
              - 'aggregator/**'
            frontend:
              - 'frontend/**'

      - name: Build service matrix
        id: service_matrix
        env:
          EVENT_NAME: ${{ github.event_name }}
          MANUAL_SERVICES: ${{ github.event.inputs.services || 'all' }}
          AGENT_CHANGED: ${{ steps.service_filter.outputs.agent }}
          AGGREGATOR_CHANGED: ${{ steps.service_filter.outputs.aggregator }}
          FRONTEND_CHANGED: ${{ steps.service_filter.outputs.frontend }}
        run: |
          python - <<'PY'
          import json
          import os

          event = os.environ.get("EVENT_NAME")
          services = []
          if event == "workflow_dispatch":
              manual_services = os.environ.get("MANUAL_SERVICES", "all").strip().lower()
              if manual_services == "all":
                  services = ["agent", "aggregator", "frontend"]
              else:
                  # Parse comma-separated list
                  services = [s.strip() for s in manual_services.split(",") if s.strip()]
                  # Validate services
                  valid_services = {"agent", "aggregator", "frontend"}
                  services = [s for s in services if s in valid_services]
                  if not services:
                      services = ["agent", "aggregator", "frontend"]  # Default to all if invalid
          else:
              mapping = {
                  "agent": os.environ.get("AGENT_CHANGED"),
                  "aggregator": os.environ.get("AGGREGATOR_CHANGED"),
                  "frontend": os.environ.get("FRONTEND_CHANGED"),
              }
              services = [svc for svc, flag in mapping.items() if flag == "true"]

          services_json = json.dumps(services)
          services_csv = ",".join(services)
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
              fh.write(f"services={services_json}\n")
              fh.write(f"services_csv={services_csv}\n")
              fh.write(f"service_count={len(services)}\n")
          PY

      - name: Apply service change gate
        id: service_gate
        env:
          RELEASE_ENABLED: ${{ env.RELEASE_ENABLED }}
          SERVICE_COUNT: ${{ steps.service_matrix.outputs.service_count }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          set -euo pipefail
          enabled="${RELEASE_ENABLED:-false}"
          count="${SERVICE_COUNT:-0}"
          # For manual triggers, always allow if services are specified
          if [[ "${EVENT_NAME}" == "workflow_dispatch" && "${count}" -gt 0 ]]; then
            enabled="true"
          elif [[ "${EVENT_NAME}" != "workflow_dispatch" && "${enabled}" == "true" && "${count}" == "0" ]]; then
            enabled="false"
            echo "Release skipped: no service directories changed."
          fi
          echo "enabled=${enabled}" >> "$GITHUB_OUTPUT"
          echo "RELEASE_ENABLED=${enabled}" >> "$GITHUB_ENV"

      - name: Determine version bump
        id: bump_level
        uses: actions/github-script@v7
        if: env.RELEASE_ENABLED == 'true'
        with:
          result-encoding: string
          script: |
            const manual =
              context.eventName === 'workflow_dispatch'
                ? (context.payload?.inputs?.bump || '')
                : '';
            if (manual) {
              core.info(`Using manual bump: ${manual}`);
              return manual;
            }
            let labels = [];
            try {
              labels = JSON.parse(process.env.LABELS_JSON || '[]').map((label) =>
                String(label || '').toLowerCase()
              );
            } catch (error) {
              core.warning(`Unable to parse labels JSON: ${error.message}`);
            }
            const has = (candidates) => labels.some(label => candidates.includes(label));
            if (has(['major release', 'major', 'breaking', 'release:major', 'semver:major'])) {
              return 'major';
            }
            if (has(['feat', 'feature', 'enhancement', 'minor', 'release:minor', 'semver:minor'])) {
              return 'minor';
            }
            if (has(['fix', 'patch', 'bug', 'bugfix', 'hotfix', 'release:patch', 'semver:patch'])) {
              return 'patch';
            }
            core.info('No bump label found; defaulting to patch');
            return 'patch';

      - name: Determine current version
        id: current_tag
        run: |
          set -euo pipefail
          latest="$(git tag --list 'v*' --sort=-v:refname | head -n 1 || true)"
          if [[ -z "$latest" ]]; then
            base="0.0.0"
          else
            base="${latest#v}"
          fi
              echo "base=$base" >> "$GITHUB_OUTPUT"
        if: env.RELEASE_ENABLED == 'true'

      - name: Calculate next version
        id: bump_version
        run: |
          set -euo pipefail
          current="${{ steps.current_tag.outputs.base }}"
          bump="${{ steps.bump_level.outputs.result }}"
          IFS='.' read -r major minor patch <<<"${current:-0.0.0}"
          major="${major:-0}"
          minor="${minor:-0}"
          patch="${patch:-0}"
          case "$bump" in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            *)
              patch=$((patch + 1))
              ;;
          esac
          version="v${major}.${minor}.${patch}"
              echo "version=$version" >> "$GITHUB_OUTPUT"
        if: env.RELEASE_ENABLED == 'true'

      - name: Create git tag
        env:
          VERSION: ${{ steps.bump_version.outputs.version }}
          TARGET_SHA: ${{ env.MERGE_SHA }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git tag "$VERSION" "$TARGET_SHA"
          git push origin "$VERSION"
        if: env.RELEASE_ENABLED == 'true'

  build-and-push:
    needs: prepare-release
    if: needs.prepare-release.outputs.version != '' && needs.prepare-release.outputs.release_enabled == 'true'
    permissions:
      contents: read
      packages: write
    uses: ./.github/workflows/build-and-publish.yml
    with:
      version: ${{ needs.prepare-release.outputs.version }}
      services: ${{ needs.prepare-release.outputs.services }}
    secrets: inherit

  update-homelab-deployments:
    needs:
      - prepare-release
      - build-and-push
    if: needs.prepare-release.outputs.version != '' && needs.prepare-release.outputs.release_enabled == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    env:
      VERSION: ${{ needs.prepare-release.outputs.version }}
      REGISTRY: ${{ vars.REGISTRY != '' && vars.REGISTRY || 'docker.io/dawker' }}
      HOMELAB_DEPLOYMENTS_REPO: ${{ vars.HOMELAB_DEPLOYMENTS_REPO != '' && vars.HOMELAB_DEPLOYMENTS_REPO || 'slashr/homelab-deployments' }}
      HOMELAB_DEPLOYMENTS_BRANCH: ${{ vars.HOMELAB_DEPLOYMENTS_BRANCH != '' && vars.HOMELAB_DEPLOYMENTS_BRANCH || 'main' }}
      HOMELAB_DEPLOYMENTS_SERVICES: ${{ vars.HOMELAB_DEPLOYMENTS_SERVICES != '' && vars.HOMELAB_DEPLOYMENTS_SERVICES || 'agent,aggregator,frontend' }}
    steps:
      - name: Check out homelab-map
        uses: actions/checkout@v4

      - name: Check out homelab-deployments
        uses: actions/checkout@v4
        with:
          repository: ${{ env.HOMELAB_DEPLOYMENTS_REPO }}
          token: ${{ secrets.HOMELAB_DEPLOYMENTS_TOKEN }}
          ref: ${{ env.HOMELAB_DEPLOYMENTS_BRANCH }}
          path: homelab-deployments

      - name: Update image tags
        env:
          CHANGED_SERVICES_JSON: ${{ needs.prepare-release.outputs.services }}
        run: |
          set -euo pipefail
          mapfile -t service_list < <(python3 - <<'PY'
          import json
          import os

          detected = json.loads(os.environ.get("CHANGED_SERVICES_JSON") or "[]")
          allowed_raw = os.environ.get("HOMELAB_DEPLOYMENTS_SERVICES", "")
          allowed = [item.strip() for item in allowed_raw.split(",") if item.strip()]
          if not allowed:
              final = detected
          else:
              final = [svc for svc in detected if svc in allowed]
          for svc in final:
              print(svc)
          PY
          )
          if [[ ${#service_list[@]} -eq 0 ]]; then
            echo "No deployments require image updates."
            exit 0
          fi
          python3 scripts/update_homelab_deployments.py \
            --repo-path homelab-deployments \
            --version "${VERSION}" \
            --registry "${REGISTRY}" \
            --services "${service_list[@]}"

      - name: Commit and push deployments update
        run: |
          set -euo pipefail
          cd homelab-deployments
          if git diff --quiet; then
            echo "No image updates detected"
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "chore: update homelab-map images to $VERSION"
          git push "https://x-access-token:${{ secrets.HOMELAB_DEPLOYMENTS_TOKEN }}@github.com/slashr/homelab-deployments.git" "HEAD:${HOMELAB_DEPLOYMENTS_BRANCH}"
